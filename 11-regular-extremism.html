<!doctype html>
<html>
  <head>
    <title>Idiosyncratic Ruby: Regular Extremism</title>
    <link rel="alternate" type="application/atom+xml" title="Idiosyncratic Ruby Feed" href="/feed.xml" />
<link href="/stylesheets/all.css" rel="stylesheet" type="text/css" />

<script src="/javascripts/jquery.min.js" type="text/javascript"></script><script src="/javascripts/pagemap.min.js" type="text/javascript"></script><script src="/javascripts/app.js" type="text/javascript"></script>

<meta charset="utf-8">
<meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
<meta name="description" content="Documenting All Ruby Specialities."/>
<meta name="keywords" content="ruby, strings, rexex"/>

  </head>

  <body>
    <div class="world">
      <canvas id="map"></canvas>

      <section class="post-header">
        <a href="/" class="post-logo"><img src="/images/idiosyncratic.png" alt="Idiosyncratic Ruby"></a>
        <h1 class="post-heading" id="top"><a href="/11-regular-extremism.html">Regular Extremism</a></h1>
      </section>

      <article class="post">
        <p>You are here for a collection of 10 advanced features of regular expressions in Ruby!</p>

<p></p>

<h2 id="regex-conditionals">Regex Conditionals</h2>

<p>Regular expressions can have embedded conditionals (<em>if-then-else</em>) with <code>(?ref)then|else</code>. "ref" stands for a group reference (number or name of a capture group):</p>

<pre><code># will match everything if string contains "ä", or only match first two chars
regex = /(.*ä)?(?(1).*|..)/

"Ruby"[regex] #=&gt; "Ru"
"Idiosyncrätic"[regex] #=&gt; "Idiosyncrätic"
</code></pre>

<h2 id="keep-expressions">Keep Expressions</h2>

<p>The possible ways to <a href="http://www.regular-expressions.info/lookaround.html">look around</a> within a regex are:</p>

<table>
  <thead>
    <tr>
      <th>Syntax</th>
      <th>Description</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>(?=X)</code></td>
      <td>Positive lookahead</td>
      <td><code>"Ruby"[/.(?=b)/]    #=&gt; "u"</code></td>
    </tr>
    <tr>
      <td><code>(?!X)</code></td>
      <td>Negative lookahead</td>
      <td><code>"Ruby"[/.(?!u)/]    #=&gt; "u"</code></td>
    </tr>
    <tr>
      <td><code>(?&lt;=X)</code></td>
      <td>Positive lookbehind</td>
      <td><code>"Ruby"[/(?&lt;=u)./]   #=&gt; "b"</code></td>
    </tr>
    <tr>
      <td><code>(?&lt;!X)</code></td>
      <td>Negative lookbehind</td>
      <td><code>"Ruby"[/(?&lt;!R|^)./] #=&gt; "b"</code></td>
    </tr>
  </tbody>
</table>

<p>But Ruby also has "Keep Expressions", an additional shortcut syntax to do <em>positive lookbehinds</em> using <code>\K</code>:</p>

<pre><code>"Ruby"[/Ru\Kby/] #=&gt; "by"
"Ruby"[/ru\Kby/] #=&gt; nil
</code></pre>

<h2 id="character-class-intersections">Character Class Intersections</h2>

<p>You can nest character classes and AND-connect them with <code>&amp;&amp;</code>. Matching all non-vowels here:</p>

<pre><code>"Idiosyncratic".scan /[[a-z]&amp;&amp;[^aeiou]]+/
# =&gt; ["d", "syncr", "t", "c"]
</code></pre>

<h2 id="regex-sub-expressions">Regex Sub-Expressions</h2>

<p>You can recursively apply regex groups again with <code>\g&lt;ref&gt;</code>. "ref" stands for a group reference (number or name of a capture group). This is different from back-references (<code>\1</code> .. <code>\9</code>), which will re-match the already matched string, instead of executing the regex again:</p>

<pre><code># match any number of sequences of 3 identical chars
regex = /((.)\2{2})\g&lt;1&gt;*/
"aaa"[regex] #=&gt; "aaa"
"abc"[regex] #=&gt; nil
"aaab"[regex] #=&gt; "aaa"
"aaabbb"[regex] #=&gt; "aaabbb"
"aaabbbc"[regex] #=&gt; "aaabbb"
"aaabbbccc"[regex] #=&gt; "aaabbbccc"
</code></pre>

<h2 id="match-characters-that-belong-together">Match Characters that Belong Together</h2>

<p><code>\X</code> treats combined characters as a single character. See <a href="https://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries">grapheme clusters</a> for more information.</p>

<pre><code>string = "R\u{030A}uby"
string[/./] #=&gt; "R"
string[/.../] #=&gt; "R̊u"
string[/\X\X/] #=&gt; "R̊u"
</code></pre>

<h2 id="relative-back-references">Relative Back-References</h2>

<p>Back-refs can be relatively referenced from the current position via <code>\k&lt;-n&gt;</code>:</p>

<pre><code>"Ruby by"[/(R)(u)(by) \k&lt;-1&gt;/] #=&gt; "Ruby by"
</code></pre>

<h2 id="deactivate-backtracking">Deactivate Backtracking</h2>

<p><a href="http://www.regular-expressions.info/atomic.html">Atomic groups</a>, defined via <code>(?&gt;X)</code>, will always try to match the first of all alternatives:</p>

<pre><code>"Rüby"[/R(u*|ü)by/]   #=&gt; "Rüby"
"Rüby"[/R(?&gt;u*|ü)by/] #=&gt; nil
</code></pre>

<h2 id="turn-on-unicode-matching-for-w-d-s-and-b">Turn On Unicode-Matching for <code>\w</code>, <code>\d</code>, <code>\s</code>, and <code>\b</code></h2>

<pre><code>"Rüby"[/\w*/] #=&gt; "R"
"Rüby"[/(?u)\w*/] #=&gt; "Rüby"
</code></pre>

<h2 id="continue-matching-at-last-match-position">Continue Matching at Last Match Position</h2>

<p>When using a method that matches a regex multiple times against a string (like <code>String#gsub</code> or <code>String#scan</code>), you can reference the position of the last match via <code>\G</code>:</p>

<pre><code>"abc1abc22abc333".scan /\Gabc./ # =&gt; ["abc1", "abc2"]
</code></pre>

<h2 id="stringsplit-with-capture-groups"><code>String#split</code> with Capture Groups</h2>

<p>The normal way of using <code>String#split</code> is this:</p>

<pre><code>"0-0".split(/-/) #=&gt; ["0", "0"]
</code></pre>

<p>But if you want to make your code as hard to read as possible, remember that captured groups will be added to the resulting array:</p>

<pre><code>"0-0".split(/(-)/) #=&gt; ["0", "-", "0"]
"0-0".split(/-(?=(.))/) #=&gt; ["0", "0", "0"]
"0-0".split(/(((-)))/) #=&gt; ["0", "-", "-", "-", "0"]
</code></pre>

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="https://ruby-doc.org/core/Regexp.html">RDoc: Regexp</a></li>
  <li><a href="https://github.com/k-takata/Onigmo/blob/master/doc/RE">Onigmo Documentation</a></li>
</ul>


        <h2>More Idiosyncratic Ruby</h2>
        <ul>
          <li><a href="https://github.com/janlelis/idiosyncratic-ruby.com/commit/2ac97dd2eac279a8c4fc2355004e141cb15406a9#all_commit_comments">Please Comment on GitHub</a></li>
            <li>Next Article: <a href="/12-more-inspections.html">More Inspections</a></li>
            <li>Previous Article: <a href="/10-know-your-environment.html">Know your Environment</a></li>
        </ul>
      </article>

      <footer>
        <div class="footer-right">
          On <a href="/">Idiosyncratic Ruby</a> by <a href="https://janlelis.com">Jan Lelis</a><br>
          
          <a href="https://janlelis.com/data-protection.html">Data Protection</a>
        </div>
        About Strings, Rexex<br>
        Last Update: November 12, 2021
      </footer>
    </div>
    <script src="/javascripts/rainbow-custom.min.js" type="text/javascript"></script>
  </body>
</html>