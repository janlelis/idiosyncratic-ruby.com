<!doctype html>
<html>
  <head>
    <title>Idiosyncratic Ruby: Try Converting</title>
    <link rel="alternate" type="application/atom+xml" title="Idiosyncratic Ruby Feed" href="/feed.xml" />
<link href="/stylesheets/all.css" rel="stylesheet" type="text/css" />

<script src="/javascripts/jquery.min.js" type="text/javascript"></script><script src="/javascripts/pagemap.min.js" type="text/javascript"></script><script src="/javascripts/app.js" type="text/javascript"></script>

<meta charset="utf-8">
<meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
<meta name="description" content="Documenting All Ruby Specialities."/>
<meta name="keywords" content="ruby, core, types"/>

  </head>

  <body>
    <div class="world">
      <canvas id="map"></canvas>

      <section class="post-header">
        <a href="/" class="post-logo"><img src="/images/idiosyncratic.png" alt="Idiosyncratic Ruby"></a>
        <h1 class="post-heading" id="top"><a href="/54-try-converting.html">Try Converting</a></h1>
      </section>

      <article class="post">
        <p>Similar to <a href="/25-meta-methodology.html">metaprogramming</a>, Ruby's type conversion system has evolved over time. While the result functions, it is also a little inconsistent and suffers from poor naming. Let's put things in perspective:</p>

<p></p>

<h2 id="implicit-and-explicit-conversion">Implicit and Explicit Conversion</h2>

<p>Ruby objects are usually converted to other classes/types using <code>to_*</code> functions. For example, converting the <a href="https://ruby-doc.org/core/String.html">String</a> <code>"42"</code> to a <a href="https://ruby-doc.org/core/Float.html">Float</a> is done with <code>to_f</code>:</p>

<pre><code>"42".to_f # =&gt; 42.0
</code></pre>

<p>This process is called <strong>explicit conversion</strong> (you want the object converted).</p>

<p>Some classes provide a second way to convert an object: <strong>implicit conversion</strong> (you expect the object to be of some type).</p>

<p>The following table shows the defined conversion methods of Ruby's important core classes:</p>

<table>
  <thead>
    <tr>
      <th>Class</th>
      <th>Explicit Conversion</th>
      <th>Implicit Conversion</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Array</td>
      <td><code>to_a</code></td>
      <td><code>to_ary</code></td>
    </tr>
    <tr>
      <td>Hash</td>
      <td><code>to_h</code></td>
      <td><code>to_hash</code></td>
    </tr>
    <tr>
      <td>String</td>
      <td><code>to_s</code></td>
      <td><code>to_str</code></td>
    </tr>
    <tr>
      <td>Integer</td>
      <td><code>to_i</code></td>
      <td><code>to_int</code></td>
    </tr>
    <tr>
      <td>Float</td>
      <td><code>to_f</code></td>
      <td>-</td>
    </tr>
    <tr>
      <td>Complex</td>
      <td><code>to_c</code></td>
      <td>-</td>
    </tr>
    <tr>
      <td>Rational</td>
      <td><code>to_r</code></td>
      <td>-</td>
    </tr>
    <tr>
      <td>Regexp</td>
      <td>-</td>
      <td><code>to_regexp</code></td>
    </tr>
    <tr>
      <td>IO</td>
      <td>-</td>
      <td><code>to_io</code></td>
    </tr>
  </tbody>
</table>

<p>In most cases you should just go with the explicit conversion method and you are good.</p>

<h2 id="expecting-a-specific-type">Expecting a Specific Type</h2>

<p>However, things are more complicated in real life. You might, and many of Ruby's core methods do, expect a compatible type that you can deal with. That is where two kinds of indirect conversion methods come into play:</p>

<h3 id="tryconvert-class-methods-implicit-conversion-or-nil"><code>.try_convert</code> Class Methods (Implicit Conversion or <code>nil</code>)</h3>

<p>Some of Ruby's core classes have a <code>try_convert</code> class method. Although its not obvious, which classes have one, and which do not have one (<code>Array</code> has one, <code>Integer</code> does not), its semantics are pretty clear: It will convert the object into an instance of the class via the <strong>implicit conversion</strong> method (e.g. <code>to_ary</code>), or, if no implicit conversion method is defined, will just return <code>nil</code>. It will also return <code>nil</code>, if the result of the conversion is <code>nil</code>, or <code>nil</code> was given as argument:</p>

<pre><code>Array.try_convert(42) # =&gt; nil
Array.try_convert(42..43) # =&gt; nil
Array.try_convert([42, 43]) # =&gt; [42, 43]
Array.try_convert(nil) # =&gt; nil

o = Object.new
def o.to_ary() [42] end
Array.try_convert(o) # =&gt; [42]
</code></pre>

<h3 id="uppercased-kernel-methods-special-conversion-or-typeerror">Uppercased Kernel Methods (Special Conversion or <code>TypeError</code>)</h3>

<p>Idiosyncratically, there is a third way of converting values: <em>Uppercased Kernel methods</em>, like <code>Array()</code>.¹ The objects you pass in will be converted to the corresponding class, following the following rules:</p>

<ul>
  <li>If there is a <strong>special conversion</strong>, apply it. See the table below for details and the exact application order (e.g. <code>Array()</code> does its special conversion <em>after</em> it tried the two steps below).</li>
  <li>Unless special conversion gets applied, try to convert via the <strong>implicit conversion</strong> method</li>
  <li>If it does not exist, try to convert via the <strong>explicit conversion</strong> method</li>
  <li>Raise a <a href="https://ruby-doc.org/core/TypeError.html">TypeError</a>² if everything of the above has failed</li>
</ul>

<p>¹ Although defining uppercased methods for your custom classes to create instances of it looks like an interesting idea at first glance, it is rather confusing. Consider defining class<code>.[]</code> instead, which enables a very similar syntax, but uses the real constant it belongs to. An example of such usage is <a href="https://ruby-doc.org/stdlib/libdoc/set/rdoc/Set.html#method-c-5B-5D">Set</a>.<br />
² Since Ruby 2.6, you can pass in a <code>exception: false</code> keyword argument to return <code>nil</code> instead of raising an error</p>

<h2 id="core-classes-conversion-table">Core Classes Conversion Table</h2>

<table class="table-10-20-15-25-X">
  <thead>
    <tr>
      <th>Class</th>
      <th><code>.try_convert</code></th>
      <th>Kernel Method</th>
      <th>Kernel Method w/ <code>nil</code></th>
      <th>Kernel Method Special</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Array</td>
      <td><a href="https://ruby-doc.org/core/Array.html#method-c-try_convert">Array.try_convert</a></td>
      <td><a href="https://ruby-doc.org/core/Kernel.html#method-i-Array">Array()</a></td>
      <td><code>Array(nil) # =&gt; []</code></td>
      <td>If <code>:to_ary</code> and <code>:to_a</code> did not return an array, it will create single-element array which contains the given value</td>
    </tr>
    <tr>
      <td>Hash</td>
      <td><a href="https://ruby-doc.org/core/Hash.html#method-c-try_convert">Hash.try_convert</a></td>
      <td><a href="https://ruby-doc.org/core/Kernel.html#method-i-Hash">Hash()</a></td>
      <td><code>Hash(nil) # =&gt; {}</code></td>
      <td><code>Hash([]) # =&gt; {}</code>. Also remember that you can convert arrays to hashes with <a href="https://ruby-doc.org/core/Hash.html#method-c-5B-5D">Hash.[]</a>.</td>
    </tr>
    <tr>
      <td>String</td>
      <td><a href="https://ruby-doc.org/core/String.html#method-c-try_convert">String.try_convert</a></td>
      <td><a href="https://ruby-doc.org/core/Kernel.html#method-i-String">String()</a></td>
      <td><code>String(nil) # =&gt; ""</code></td>
      <td>-</td>
    </tr>
    <tr>
      <td>Integer</td>
      <td><a href="https://ruby-doc.org/core/Integer.html#method-c-try_convert">Integer.try_convert</a>⁴</td>
      <td><a href="https://ruby-doc.org/core/Kernel.html#method-i-Integer">Integer()</a></td>
      <td><code>Integer(nil) # TypeError</code></td>
      <td>Special behavior for strings: Instead of calling <a href="https://ruby-doc.org/core/String.html#method-i-to_i">String#to_i</a>, it will be more rigid². Takes a second argument defining the <a href="https://en.wikipedia.org/wiki/Radix">numerical base</a>. Also see ³</td>
    </tr>
    <tr>
      <td>Float</td>
      <td>-</td>
      <td><a href="https://ruby-doc.org/core/Kernel.html#method-i-Float">Float()</a></td>
      <td><code>Float(nil) # TypeError</code></td>
      <td>- ³</td>
    </tr>
    <tr>
      <td>Complex</td>
      <td>-</td>
      <td><a href="https://ruby-doc.org/core/Kernel.html#method-i-Complex">Complex()</a></td>
      <td><code>Complex(nil) # TypeError</code></td>
      <td>-</td>
    </tr>
    <tr>
      <td>Rational</td>
      <td>-</td>
      <td><a href="https://ruby-doc.org/core/Kernel.html#method-i-Rational">Rational()</a></td>
      <td><code>Rational(nil) # TypeError</code></td>
      <td>-</td>
    </tr>
    <tr>
      <td>Regexp</td>
      <td><a href="https://ruby-doc.org/core/Regexp.html#method-c-try_convert">Regexp.try_convert</a></td>
      <td>-</td>
      <td>-</td>
      <td>-</td>
    </tr>
    <tr>
      <td>IO</td>
      <td><a href="https://ruby-doc.org/core/IO.html#method-c-try_convert">IO.try_convert</a></td>
      <td>-</td>
      <td>-</td>
      <td>-</td>
    </tr>
  </tbody>
</table>

<p>.</p>

<p>² It will only convert strings that contain exactly an integer. It would not accept "42A", which <code>String#to_i</code> would happily take. It also accepts <a href="https://idiosyncratic-ruby.com/39-fixed-numbers.html">radix prefixes and numbers that contain underscores</a>, so basically it accepts the same format that is valid for direct integer literals in Ruby. Will raise an <code>ArgumentError</code> if an invalid string is passed in.<br />
³ It will convert to other low-level numerical types (such as integers and floats) directly, so <code>Float(4)</code> will <em>not</em> call <code>4.to_f</code><br />
⁴ Added in Ruby 3.1</p>

<h2 id="when-to-use-what">When to Use What?</h2>

<ul>
  <li>Prefer <strong>explicit conversion</strong>: <code>to_*</code> methods</li>
  <li>Use <code>.try_convert</code> for <strong>implicit conversion</strong></li>
  <li>Use the uppercased Kernel methods for their special effects, like <code>Array()</code> for wrapping single arguments in an arrays, or <code>Integer()</code> for strict integer conversion</li>
</ul>


        <h2>More Idiosyncratic Ruby</h2>
        <ul>
          <li><a href="https://github.com/janlelis/idiosyncratic-ruby.com/commit/98e8de49193e1f636d90431b2374c09ca0de4da7#all_commit_comments">Please Comment on GitHub</a></li>
            <li>Next Article: <a href="/55-struggling-four-equality.html">Struggling Four Equality</a></li>
            <li>Previous Article: <a href="/53-the-constant-tree.html">The Constant Tree</a></li>
        </ul>
      </article>

      <footer>
        <div class="footer-right">
          On <a href="/">Idiosyncratic Ruby</a> by <a href="https://janlelis.com">Jan Lelis</a><br>
          Article Contributions by: Yauheni Dakuka<br>
          <a href="https://janlelis.com/data-protection.html">Data Protection</a>
        </div>
        About Core, Types<br>
        Last Update: December 27, 2021
      </footer>
    </div>
    <script src="/javascripts/rainbow-custom.min.js" type="text/javascript"></script>
  </body>
</html>